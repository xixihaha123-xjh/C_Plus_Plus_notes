# tcpdump及wireshark使用

参考网址：

[Wireshark和TcpDump抓包分析心得]: https://blog.csdn.net/zrzlj/article/details/6076219?utm_source=app
[网络抓包工具 wireshark 入门教程]: https://blog.csdn.net/zjy900507/article/details/79303359?utm_source=app



# 1 tcpdump

## 1.1 介绍

### 1.1.1 tcpdump抓包必须开启网卡混杂模式

1. 如果要使用*tcpdump*抓取其他主机*MAC*地址的数据包，必须开启网卡混杂模式，所谓混杂模式，用最简单的语言就是让网卡抓取任何经过它的数据包，不管这个数据包是不是发给它或者是它发出的

```shell
# 开启网卡混杂模式,eth0 是你要打开混杂模式的网卡
ifconfig eth0 promisc
```

### 1.1.2 抓包参数

1.  使用SSH登录到远程*Linux*，然后直接运行*tcpdump*，会发现抓到大量的数据包，速度快的都看不清楚，这是因为*tcpdump*抓到的包发送给远程的终端显示，同时又抓了这个包，再显示，再抓取，造成了循环抓取
2. tcpdump默认选择第一块网卡，也就是eth0进行抓包
3. 参数 `-i` 指定从哪一个网卡抓包

```shell
tcpdump -i eth1
tcpdump -i any   # 任意网卡
```

4. 参数 `-D` 想知道我们可以通过哪几个网卡抓包

```shell
tcpdump -D
1.eth0
2.nflog (Linux netfilter log (NFLOG) interface)
3.nfqueue (Linux netfilter queue (NFQUEUE) interface)
4.usbmon1 (USB bus number 1)                                # 抓取 usb
5.any (Pseudo-device that captures on all interfaces)       # 任意一块网卡进行抓包
6.lo [Loopback]                                             # 回环地址
```

5. 参数 `-w` 抓包结果保存到文件中

```shell
tcpdump –w google.cap
```

6. 参数`-s`  防止包截断

```
tcpdump -s 0
```



## 1.2 抓包过滤器

### 1.2.1 指定类型

1. `host` 定义抓取哪个ip地址的数据包，也可以是mac地址

```shell
tcpdump host 192.168.0.2       # 抓取从192.168.0.2发出或发送给192.168.0.2的数据包
```

2. `net` 定义抓取某个网络的数据包，给出网络号就行，它根据网络号字节序数是1 - 2 -3来判断A、B、C类地址

```shell
tcpdump net 192.168.1          # 这是一个C类地址
```

3. port 指定端口

```shell
tcpdump port 5060 or 8800        
```



### 1.2.2 指定方向

1. 抓取发出的数据包

```shell
tcpdump src host 192.168.0.2
```

2. 抓取发向的数据包

```
tcpdump dst host 192.168.0.2
```

### 1.2.3 指定协议



# 2 wireshark

## 2.1 简介

1. Wireshark通过WinPcap进行抓包，pcap（Process Characterization Analysis Package），wireshark对libpcap或winpcap抓到的数据包进行分析解码  

2. wireshark作用：网络管理员使用Wireshark来检测网络问题、**网络故障分析**，网络安全工程师使用Wireshark来检查资讯安全相关问题，开发者使用Wireshark来为新的通讯协定除错、**程序接口分析**，普通使用者使用Wireshark来学习网络协定的相关知识。当然，有的人也会“居心叵测”的用它来寻找一些**敏感信息**……。 









## 2.2 抓包过滤器或者显示过滤器





# 3 混杂模式

1. 设置网卡为混杂模式就能捕获局域网内所有发包内容，包括非广播包和非发给自己主机的数据包。

2. 原理分析：

* 先说说网卡的工作原理。网卡收到传输来的数据，网卡内的单片程序先接收数据头的目的MAC地址，根据计算机上的网卡驱动程序设置的接收模式判断该不该接收，认为该接收就在接收后产生中断信号通知CPU，认为不该接收就丢弃不管，所以不该接收的数据网卡就截断了，计算机根本就不知道。CPU得到中断信号产生中断，操作系统就根据网卡驱动程序中设置的网卡中断程序地址调用驱动程序接收数据，驱动程序接收数据后放入信号堆栈让操作系统处理。

* 再说说局域网如何工作。 数据在网络上是以很小的称为帧(Frame)的单位传输的。帧由好几部分组成，不同的部分执行不同的功能。（例如，以太网的前12个字节存放的是源和目的的地址，这些位告诉网络：数据的来源和去处。以太网帧的其他部分存放实际的用户数据、TCP/IP的报文头或IPX报文头等等）。

* 帧通过特定的网络驱动程序进行成型，然后通过网卡发送到网线上。通过网线到达它们的目的机器，在目的机器的一端执行相反的过程。接收端机器的以太网卡捕获到这些帧，并告诉操作系统帧的到达，然后对其进行存储。就是在这个传输和接收的过程中，嗅探器会造成安全方面的问题。通常在局域网（LAN）中同一个网段的所有网络接口都有访问在物理媒体上传输的所有数据的能力，而每个网络接口都还应该有一个硬件地址，该硬件地址不同于网络中存在的其他网络接口的硬件地址，同时，每个网络至少还要一个广播地址。（代表所有的接口地址），在正常情况下，一个合法的网络接口应该只响应这样的两种数据帧：　1、帧的目标区域具有和本地网络接口相匹配的硬件地址。　2、帧的目标区域具有“广播地址”。在接受到上面两种情况的数据包时，网卡通过cpu产生一个硬件中断，该中断能引起操作系统注意，然后将帧中所包含的数据传送给系统进一步处理。当采用共享HUB，用户发送一个报文时，这些报文就会发送到LAN上所有可用的机器。在一般情况下，网络上所有的机器都可以“听”到通过的流量，但对不属于自己的报文则不予响应（换句话说，工作站A不会捕获属于工作站B的数据，而是简单的忽略这些数据）。如果局域网中某台机器的网络接口处于混杂（promiscuous）模式（即网卡可以接收其收到的所有数据包，下面会详细地讲），那么它就可以捕获网络上所有的报文和帧，如果一台机器被配置成这样的方式，它（包括其软件）就是一个嗅探器。

* 然后要知道嗅探要捕获的东西必须是要物理信号能收到的报文信息。显然只要通知网卡接收其收到的所有包（一般叫作混杂promiscuous模式：指网络上的所有设备都对总线上传送的数据进行侦听，并不仅仅是它们自己的数据。），在共享HUB下就能接收到这个网段的所有包，但是交换模式下就只能是自己的包加上广播包。要想在交换模式下接收别人的包，那就要让其发往你的机器所在口。交换模式记住一个口的MAC是通过接收来自这个口的数据后并记住其源MAC，就像一个机器的IP与MAC对应的ARP列表，交换模式维护一个物理口（就是HUB上的网线插口，这之后提到的所有HUB口都是指网线插口）与MAC的表，所以可以欺骗交换模式的。可以发一个包设置源MAC是你想接收的机器的MAC，那么交换模式就把你机器的网线插的物理口与那个MAC对应起来了，以后发给那个MAC的包就发往你的网线插口了，也就是你的网卡可以嗅探到了。注意这物理口与MAC的表与机器的ARP表一样是动态刷新的，那机器发包后交换模式就又记住他的口了，所以实际上是两个在争，这只能应用在只要收听少量包就可以的场合。内部网基于IP的通信可以用ARP欺骗别人机器让其发送给你的机器，如果要想不影响原来两方的通信，可以欺骗两方，都发给你的机器再由你的机器转发，相当于做中间人，这用ARP加上编程很容易实现。并且现在很多设备支持远程管理，有很多交换模式可以设置一个口监听别的口，不过这就要管理权限了。利用这一点，可以将一台计算机的网络连接设置为接受所有以太网总线上的数据，从而实现嗅探。